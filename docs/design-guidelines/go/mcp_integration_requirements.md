# MCP-интеграция (эталон)

## Цель

Обеспечить безопасную и предсказуемую интеграцию Codex-конфига с MCP-серверами,
включая `yaml-mcp-server` и связанные approval-потоки.

## Контракт `codex.mcp.servers`

Поддерживаемые типы:

- `stdio`
- `http` / `https`
- `cluster`

Обязательные требования:

- уникальное `name`;
- валидный endpoint/command по типу;
- корректные timeout-поля;
- отсутствие секретов в literal-значениях.

## Секреты и переменные

- Секреты не хранятся в `services.yaml`.
- Используются только `envRef` или `varRef`.
- Чувствительные заголовки и токены прокидываются через env.

## Таймауты

- Для каждого MCP-сервера задается `tool_timeout_sec`.
- Для approval-сценариев timeout учитывает человеческое ожидание.
- Клиентский timeout не должен преждевременно обрывать long-running approval flow.

## Интеграция с `yaml-mcp-server`

`codexctl` обязан:

- формировать корректный `mcp_servers.*` блок в `config.toml`;
- поддерживать cluster-адресацию через service DNS;
- поддерживать безопасные заголовки через env-механизм;
- не дублировать семантику YAML DSL tool внутри `codexctl`.

## Интеграция с `telegram-approver`

`codexctl` не интегрируется с ним напрямую в use-case слое.

`codexctl` обязан учитывать, что через `yaml-mcp-server`:

- approval может быть async и долгим;
- callback и decision происходят во внешнем контуре;
- агентские сценарии должны работать с моделью eventual completion.

## Платформенная независимость

MCP-конфигурация не должна быть привязана к конкретной реализации
`Orchestrator` или `Repository`.

Добавление `docker-compose` или `gitlab` не должно требовать переписывания MCP DSL контракта в `codexctl`.

## Валидация

- Рендер `config.toml` должен падать при невалидной MCP-конфигурации.
- Ошибки должны указывать точный сервер и проблемное поле.
