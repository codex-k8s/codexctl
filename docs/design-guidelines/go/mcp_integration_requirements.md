# MCP-интеграция (эталон)

## Цель

Обеспечить безопасную и предсказуемую интеграцию Codex-конфига с MCP-серверами,
включая `yaml-mcp-server` и связанные approval-потоки.

## Контракт `codex.mcp.servers`

Поддерживаемые типы:

- `stdio`
- `http` / `https`
- `cluster`

Обязательные требования:

- уникальное `name`;
- валидный endpoint/command по типу;
- корректные timeout-поля;
- отсутствие секретов в literal-значениях.

## Секреты и переменные

- Секреты не хранятся в `services.yaml`.
- Используются только `envRef` или `varRef`.
- Все чувствительные заголовки и токены прокидываются через env.

## Таймауты

- Для каждого MCP-сервера задается `tool_timeout_sec` на основе SLA конкретных tool.
- Для approval-сценариев timeout должен учитывать человеческое ожидание.
- Нельзя оставлять длительные approval-flow на слишком коротком client timeout.

## Интеграция с `yaml-mcp-server`

`codexctl` обязан:

- формировать корректный `mcp_servers.*` блок в результирующем `config.toml`;
- поддерживать cluster-адресацию через service DNS;
- поддерживать безопасные заголовки через env-механизм;
- не дублировать семантику YAML DSL tool внутри `codexctl`.

## Интеграция с `telegram-approver`

`codexctl` не интегрируется с ним напрямую на уровне бизнес-логики.

`codexctl` обязан учитывать, что:

- approval-flow через `yaml-mcp-server` может быть asynchronous и долгим;
- callback и решение об approval обрабатываются внешним контуром;
- сценарии агента не должны считаться синхронными, если tool требует внешнего подтверждения.

## Валидация

- Рендер `config.toml` должен падать при невалидной MCP-конфигурации.
- Сообщения ошибок должны указывать точный сервер и проблемное поле.
