# Принципы проектирования (эталон)

## Базовые принципы

Обязательные принципы для `codexctl`:

- SOLID
- DRY
- KISS
- Clean Architecture
- Interface First
- Explicit Contracts

## Interface First

- Сначала задается контракт порта (`Orchestrator`, `Repository`), затем реализация.
- Контракт отражает потребности use-case, а не детали SDK.
- Контракт проектируется так, чтобы поддержать минимум 2 реализации:
  - текущая production-реализация;
  - альтернативная платформа (например, Docker Compose или GitLab).

## SOLID для CLI-оркестратора

- SRP: один use-case/модуль отвечает за один orchestration-сценарий.
- OCP: новая платформа добавляется новым адаптером, а не переписыванием use-case.
- LSP: любая реализация `Orchestrator`/`Repository` заменяема без изменения application-кода.
- ISP: интерфейсы узкие и сценарно-ориентированные.
- DIP: прикладной слой зависит от интерфейсов, не от SDK-клиентов.

## DRY

- Повторяемые orchestration-шаги живут в одном месте.
- Retry/timeout/error mapping задаются единообразно.
- Reusable workflow не дублируют логику в wrapper-репозиториях.

## KISS

- Сценарии линейные и читаемые.
- Абстракция вводится только при снижении связности.
- Избыточные универсальные фасады и god-интерфейсы запрещены.

## Clean Architecture

- `application` и `core` не импортируют конкретные SDK.
- SDK и внешние протоколы живут в adapter-слое.
- Core-policy не зависит от платформы оркестратора или provider репозитория.

## Контрактность и совместимость

- CLI-флаги и `CODEXCTL_*` env — публичный контракт.
- Формат `services.yaml` — публичный контракт.
- Reusable workflow интерфейсы — публичный контракт.
- Контракты `Orchestrator`/`Repository` — внутренний архитектурный контракт.

Breaking изменения допускаются только с:

- миграционным планом;
- обновлением документации;
- явной фиксацией несовместимости.
